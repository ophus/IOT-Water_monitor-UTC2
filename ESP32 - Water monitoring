#include <WiFiManager.h>
#include <HTTPClient.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include <math.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include "DFRobot_PH.h"
#include <EEPROM.h>

#define UPDATE_INTERVAL 30000
#define POLL_INTERVAL 2000
#define DATA_SEND_INTERVAL 2000

#define LED_PIN 2   
#define PH_PIN 34   
#define TEMP_PIN 32 
#define TDS_PIN 33  
#define TUR_PIN 35  
#define RELAY_PIN1 4
#define RELAY_PIN2 5

#define VREF 3.3
#define SCOUNT 15        
#define BETA 3950  
#define SERIES_RESISTOR 10000  
#define K_VALUE 1.0 * (900) 
#define CONVERSION_FACTOR 0.5

// Define c√°c ng∆∞·ª°ng cho ph√©p
#define MIN_PH 6.5
#define MAX_PH 8.5
#define MIN_TDS 100
#define MAX_TDS 500
#define MIN_TEMP 20
#define MAX_TEMP 35
#define MIN_TURBIDITY 0
#define MAX_TURBIDITY 50
 
// Th√™m c√°c bi·∫øn to√†n c·ª•c
#define MAX_READINGS 50  // S·ªë l∆∞·ª£ng m·∫´u t·ªëi ƒëa ƒë·ªÉ t√≠nh trung b√¨nh

float tempReadings[MAX_READINGS];
float phReadings[MAX_READINGS];
float tdsReadings[MAX_READINGS];
float turReadings[MAX_READINGS];
int readingCount = 0;

const float U0 = 3600.0; 
int ADC_cal = 1700;  // Gi√° tr·ªã ADC khi pH = 6.86
const float pH_Ref = 6.86; // Gi√° tr·ªã pH tham chi·∫øu
float Slope = -0.0675; // Gi√° tr·ªã Slope c√≥ th·ªÉ ƒëi·ªÅu ch·ªân
int buffer[SCOUNT];  // B·ªô ƒë·ªám l∆∞u gi√° tr·ªã ADC
float temperature = 0;
Preferences preferences;

DFRobot_PH ph;
OneWire oneWire(TEMP_PIN);
DallasTemperature sensors(&oneWire);

int analogBuffer[SCOUNT];
int analogBufferIndex = 0;
float tdsVoltage = 0, tdsValue = 0;
bool continuousMeasurement = false;

WebServer server(80);
String workerUrl = "https://esp32-data-receiver.phucminh9395.workers.dev";
unsigned long lastUpdateTime = 0;
unsigned long lastPollTime = 0;
unsigned long lastDataSendTime = 0;
bool sendDataEnabled = false;
#define HEARTBEAT_INTERVAL 10000 // 5 gi√¢y
unsigned long lastHeartbeatTime = 0;

void sendIPToWorker() {
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(workerUrl + "/update_ip");
        http.addHeader("Content-Type", "application/json");
        String jsonPayload = "{\"ip\":\"" + WiFi.localIP().toString() + "\"}";
        Serial.println("üì§ G·ª≠i IP l√™n Worker: " + jsonPayload);
        int httpResponseCode = http.POST(jsonPayload);
        Serial.print("üì§ M√£ ph·∫£n h·ªìi: ");
        Serial.println(httpResponseCode);
        http.end();
    }
}

void checkAndUpdateIP() {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("‚ùå M·∫•t k·∫øt n·ªëi WiFi! Th·ª≠ k·∫øt n·ªëi l·∫°i...");
        WiFi.reconnect();
        delay(5000);
        if (WiFi.status() != WL_CONNECTED) {
            Serial.println("üö® WiFi v·∫´n kh√¥ng k·∫øt n·ªëi, kh·ªüi ƒë·ªông l·∫°i ESP32!");
            ESP.restart();
        }
    } else if (millis() - lastUpdateTime > UPDATE_INTERVAL) {
        sendIPToWorker();
        lastUpdateTime = millis();
    }
}

// H√†m th√™m d·ªØ li·ªáu v√†o m·∫£ng
void addReadings(float temp, float ph, float tds, float turbidity) {
    if (readingCount < MAX_READINGS) {
        tempReadings[readingCount] = temp;
        phReadings[readingCount] = ph;
        tdsReadings[readingCount] = tds;
        turReadings[readingCount] = turbidity;
        readingCount++;
    }
}

// H√†m t√≠nh gi√° tr·ªã trung b√¨nh
float calculateAverage(float arr[], int size) {
    float sum = 0;
    for (int i = 0; i < size; i++) {
        sum += arr[i];
    }
    return sum / size;
}

int getMedianNum(int bArray[], int iFilterLen) {
    int bTab[iFilterLen];
    for (byte i = 0; i < iFilterLen; i++)
        bTab[i] = bArray[i];
    int i, j, bTemp;
    for (j = 0; j < iFilterLen - 1; j++) {
        for (i = 0; i < iFilterLen - j - 1; i++) {
            if (bTab[i] > bTab[i + 1]) {
                bTemp = bTab[i];
                bTab[i] = bTab[i + 1];
                bTab[i + 1] = bTemp;
            }
        }
    }
    return (iFilterLen & 1) > 0 ? bTab[(iFilterLen - 1) / 2] : (bTab[iFilterLen / 2] + bTab[iFilterLen / 2 - 1]) / 2;
}

float tempRead(){
    sensors.requestTemperatures();
    temperature = sensors.getTempCByIndex(0); // ƒê·ªçc nhi·ªát ƒë·ªô (¬∞C)
    return temperature;
}

float tdsRead(){
  // L∆∞u gi√° tr·ªã ADC v√†o b·ªô ƒë·ªám
    analogBuffer[analogBufferIndex] = analogRead(TDS_PIN);
    analogBufferIndex++;
    if (analogBufferIndex == SCOUNT) analogBufferIndex = 0;

    // L·ªçc gi√° tr·ªã ADC b·∫±ng thu·∫≠t to√°n trung v·ªã
    int filteredADC = getMedianNum(analogBuffer, SCOUNT);

    // Chuy·ªÉn ƒë·ªïi ADC sang Volt
    tdsVoltage = (filteredADC / 4095.0) * VREF;

    // T√≠nh TDS tr∆∞·ªõc hi·ªáu ch·ªânh
    float tdsRaw = 973 * tdsVoltage; // H·ªá s·ªë hi·ªáu ch·ªânh ban ƒë·∫ßu

    // Hi·ªáu ch·ªânh TDS theo nhi·ªát ƒë·ªô
    float tdsValue = tdsRaw / (1.0 + 0.02 * (temperature - 25)); // C√¥ng th·ª©c b√π nhi·ªát
    return tdsValue;
}

float phRead() {
  for (int i = 0; i < SCOUNT; i++) {
    buffer[i] = analogRead(PH_PIN);
    delay(10);  // Delay nh·ªè ƒë·ªÉ tr√°nh nhi·ªÖu
  }

  int rawADC = getMedianNum(buffer, SCOUNT);  // L·ªçc gi√° tr·ªã ADC b·∫±ng trung v·ªã
  float phVoltage = (rawADC / 4095.0) * VREF;   // Chuy·ªÉn ƒë·ªïi ADC sang Volt

  float real_phVoltage = phVoltage * ((10+20)/20);

  // T√≠nh to√°n pH theo ƒë∆∞·ªùng tuy·∫øn t√≠nh - FIXED FORMULA
  float phValue = pH_Ref + Slope * (real_phVoltage - ADC_cal / 4095.0 * VREF);
  return phValue;
}

float convertTurbidity(int analogValue) {
    float Um = (analogValue / 4095.0) * 5000;
    float f = Um / U0;
    return (f >= 0.98 && f <= 1.000) ? 0 : map(f * 100, 0, 100, 1000, 0);
}

float turRead(){
    int turRaw = analogRead(TUR_PIN);
    float turbidity = convertTurbidity(turRaw);
    if (turbidity < 0) { turbidity = 0;}
    return turbidity;
}

String getSensorData() {

    float temperature = round(tempRead() * 100)/100;
    float phValue = round(phRead()* 100)/100;
    float tdsValue = round(tdsRead()* 100)/100;
    float turbidity = round(turRead()* 100)/100;

    addReadings(temperature,phValue,tdsValue,turbidity);

    DynamicJsonDocument doc(512);
    doc["temperature"] = temperature;
    doc["ph"] = phValue;
    doc["tds"] = tdsValue;
    doc["turbidity"] = turbidity;
    String json;
    serializeJson(doc, json);
    return json;
}

void sendSensorDataToWorker() {
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(workerUrl + "/push_data");
        http.addHeader("Content-Type", "application/json");
        String jsonPayload = getSensorData();
        Serial.println("üì§ G·ª≠i d·ªØ li·ªáu c·∫£m bi·∫øn: " + jsonPayload);
        int httpResponseCode = http.POST(jsonPayload);
        Serial.print("üì§ M√£ ph·∫£n h·ªìi: ");
        Serial.println(httpResponseCode);
        if (httpResponseCode == HTTP_CODE_OK) {
            String response = http.getString();
            Serial.print("üì§ Ph·∫£n h·ªìi: ");
            Serial.println(response);
        } else {
            Serial.print("‚ùå L·ªói g·ª≠i d·ªØ li·ªáu, m√£: ");
            Serial.println(httpResponseCode);
        }
        http.end();
    } else {
        Serial.println("‚ùå WiFi kh√¥ng k·∫øt n·ªëi, kh√¥ng th·ªÉ g·ª≠i d·ªØ li·ªáu!");
    }
}

void pollForCommands() {
    if (WiFi.status() != WL_CONNECTED) { // kiem tra ket noi wifi
        Serial.println("‚ùå WiFi kh√¥ng k·∫øt n·ªëi, kh√¥ng th·ªÉ thƒÉm d√≤ l·ªánh!");
        return;
    }
    
    Serial.println("üì• ƒêang thƒÉm d√≤ l·ªánh...");
    HTTPClient http;
    http.begin(workerUrl + "/poll_command");
    http.addHeader("Content-Type", "application/json");
    int httpResponseCode = http.POST("{}");
    Serial.print("üì• M√£ ph·∫£n h·ªìi: ");
    Serial.println(httpResponseCode); 
    if (httpResponseCode == HTTP_CODE_OK) {
        String response = http.getString();
        Serial.print("üì• D·ªØ li·ªáu JSON th√¥: ");
        Serial.println(response);
        
        // Ki·ªÉm tra xem response c√≥ r·ªóng ho·∫∑c kh√¥ng ph·∫£i JSON kh√¥ng
        if (response.length() == 0 || response.equals("{}") || response.equals("[]")) {
            Serial.println("üì• Kh√¥ng c√≥ l·ªánh m·ªõi.");
            http.end();
            return;
        }
        
        DynamicJsonDocument doc(512); // TƒÉng k√≠ch th∆∞·ªõc buffer
        DeserializationError error = deserializeJson(doc, response);
        
        if (!error) {
            // Ki·ªÉm tra xem JSON c√≥ ch·ª©a c√°c ch·ªØ s·ªë l√† key kh√¥ng (format t·ª´ worker)
            if (doc.containsKey("0")) {
                // X√¢y d·ª±ng l·∫°i l·ªánh t·ª´ c√°c k√Ω t·ª± ri√™ng l·∫ª
                String action = "";
                int index = 0;
                char indexStr[3];
                while (true) {
                    sprintf(indexStr, "%d", index);
                    if (!doc.containsKey(indexStr)) break;
                    action += doc[indexStr].as<String>();
                    index++;
                }
                
                Serial.print("‚úÖ ƒê√£ t·∫°o l·∫°i l·ªánh t·ª´ c√°c k√Ω t·ª± ri√™ng l·∫ª: ");
                Serial.println(action);
                
                if (action.length() > 0) {
                    String result = executeCommand(action);
                    sendCommandResult(action, result);
                }
            }
            // V·∫´n gi·ªØ l·∫°i ki·ªÉm tra action c≈© n·∫øu format thay ƒë·ªïi trong t∆∞∆°ng lai
            else if (doc.containsKey("action")) {
                String action = doc["action"].as<String>();
                Serial.print("‚úÖ Th·ª±c thi l·ªánh: ");
                Serial.println(action);
                String result = executeCommand(action);
                sendCommandResult(action, result);
            } else {
                Serial.println("‚ùå JSON kh√¥ng theo ƒë·ªãnh d·∫°ng mong ƒë·ª£i!");
            }
        } else {
            Serial.print("‚ùå L·ªói ph√¢n t√≠ch JSON: ");
            Serial.println(error.c_str());
        }
    } else {
        Serial.println("‚ùå Kh√¥ng th·ªÉ thƒÉm d√≤ l·ªánh.");
    }
    http.end();
}

String executeCommand(String action) {
    if (action == "measure") {
        continuousMeasurement = true;
        Serial.println("‚úÖ Continuous measurement enabled");
        return "Measurement started";
    } else if (action == "test") {
        // Single measurement
        sendSensorDataToWorker();
        Serial.println("‚úÖ Single test measurement sent");
        return "Test measurement completed";
    } else if (action == "stop") {
        continuousMeasurement = false;
        Serial.println("‚èπÔ∏è Measurement stopped");

        if (readingCount > 0) {
            // T√≠nh gi√° tr·ªã trung b√¨nh
            float avgTemp = calculateAverage(tempReadings, readingCount);
            float avgPH = calculateAverage(phReadings, readingCount);
            float avgTDS = calculateAverage(tdsReadings, readingCount);
            float avgTurbidity = calculateAverage(turReadings, readingCount);
            
            Serial.println("üìä Gi√° tr·ªã trung b√¨nh:");
            Serial.println("üå°Ô∏è Nhi·ªát ƒë·ªô: " + String(avgTemp));
            Serial.println("üìà pH: " + String(avgPH));
            Serial.println("üíß TDS: " + String(avgTDS));
            Serial.println("üåä ƒê·ªô ƒë·ª•c: " + String(avgTurbidity));
            
            // Ki·ªÉm tra v√† ƒëi·ªÅu khi·ªÉn relay
            checkAndControlRelays(avgTemp, avgPH, avgTDS, avgTurbidity);
        }
        return "Measurement stopped";
    } else if (action == "restart") {
        Serial.println("üîÑ ƒêang kh·ªüi ƒë·ªông l·∫°i ESP32...");
        delay(1000);
        ESP.restart();
        return "Restarting device";
    } else if (action == "status") {
        String status = "WiFi: " + String(WiFi.RSSI()) + " dBm, IP: " + WiFi.localIP().toString();
        return status;
    }
    return "Unknown command: " + action;
}

void sendCommandResult(String action, String result) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("‚ùå WiFi kh√¥ng k·∫øt n·ªëi, kh√¥ng th·ªÉ g·ª≠i k·∫øt qu·∫£!");
        return;
    }
    
    HTTPClient http;
    http.begin(workerUrl + "/command_result");
    http.addHeader("Content-Type", "application/json");
    
    DynamicJsonDocument doc(512);
    doc["action"] = action;
    doc["result"] = result;
    String json;
    serializeJson(doc, json);
    
    Serial.println("üì§ G·ª≠i k·∫øt qu·∫£ l·ªánh: " + json);
    int httpResponseCode = http.POST(json);
    Serial.print("üì§ M√£ ph·∫£n h·ªìi: ");
    Serial.println(httpResponseCode);
    http.end();
}

void handleCommand() {
    if (server.hasArg("plain")) {
        String requestBody = server.arg("plain");
        Serial.println("üì• L·ªánh nh·∫≠n ƒë∆∞·ª£c: " + requestBody);
        
        DynamicJsonDocument doc(512);
        DeserializationError error = deserializeJson(doc, requestBody);
        
        if (error) {
            Serial.print("‚ùå L·ªói ph√¢n t√≠ch JSON t·ª´ y√™u c·∫ßu web: ");
            Serial.println(error.c_str());
            server.send(400, "application/json", "{\"error\": \"Invalid JSON: " + String(error.c_str()) + "\"}");
            return;
        }
        
        if (!doc.containsKey("action")) {
            server.send(400, "application/json", "{\"error\": \"Missing 'action' field\"}");
            return;
        }
        
        String action = doc["action"].as<String>();
        String result = executeCommand(action);
        server.send(200, "application/json", "{\"message\": \"" + result + "\"}");
    } else {
        server.send(400, "application/json", "{\"error\": \"No command received\"}");
    }
}

void sendHeartbeat() {
    if (WiFi.status() == WL_CONNECTED) {
        HTTPClient http;
        http.begin(workerUrl + "/heartbeat");
        http.addHeader("Content-Type", "application/json");
        int httpResponseCode = http.POST("{}");
        Serial.print("üíì Heartbeat sent, response code: ");
        Serial.println(httpResponseCode);
        http.end();
    }
}

// H√†m ki·ªÉm tra v√† ƒëi·ªÅu khi·ªÉn relay
void checkAndControlRelays(float avgTemp, float avgPH, float avgTDS, float avgTurbidity) {
    bool isWithinRange = true;
    
    // Ki·ªÉm tra t·ª´ng th√¥ng s·ªë
    if (avgPH < MIN_PH || avgPH > MAX_PH) {
        Serial.println("‚ö†Ô∏è pH n·∫±m ngo√†i kho·∫£ng cho ph√©p!");
        isWithinRange = false;
    }
    if (avgTDS < MIN_TDS || avgTDS > MAX_TDS) {
        Serial.println("‚ö†Ô∏è TDS n·∫±m ngo√†i kho·∫£ng cho ph√©p!");
        isWithinRange = false;
    }
    if (avgTemp < MIN_TEMP || avgTemp > MAX_TEMP) {
        Serial.println("‚ö†Ô∏è Nhi·ªát ƒë·ªô n·∫±m ngo√†i kho·∫£ng cho ph√©p!");
        isWithinRange = false;
    }
    if (avgTurbidity < MIN_TURBIDITY || avgTurbidity > MAX_TURBIDITY) {
        Serial.println("‚ö†Ô∏è ƒê·ªô ƒë·ª•c n·∫±m ngo√†i kho·∫£ng cho ph√©p!");
        isWithinRange = false;
    }
    
    // ƒêi·ªÅu khi·ªÉn relay
    if (isWithinRange) {
        digitalWrite(RELAY_PIN1, LOW);
        digitalWrite(RELAY_PIN2, HIGH);
        Serial.println("‚úÖ Th√¥ng s·ªë n·∫±m trong kho·∫£ng cho ph√©p. K√≠ch ho·∫°t RELAY_PIN2");
        delay(5000);
        digitalWrite(RELAY_PIN2, LOW);
    } else {
        digitalWrite(RELAY_PIN1, HIGH);
        digitalWrite(RELAY_PIN2, LOW);
        Serial.println("‚ùå Th√¥ng s·ªë n·∫±m ngo√†i kho·∫£ng cho ph√©p. K√≠ch ho·∫°t RELAY_PIN1");
        delay(5000);
        digitalWrite(RELAY_PIN1, LOW);
    }
}

void setup() {
    Serial.begin(115200);
    Serial.println("\n\n=== ESP32 Water Monitoring System ===");
    
    // K·∫øt n·ªëi WiFi
    WiFiManager wifiManager;
    wifiManager.setConfigPortalTimeout(180); // timeout sau 3 ph√∫t
    
    if (!wifiManager.autoConnect("ESP32_Water_Monitor", "12345678")) {
        Serial.println("‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi WiFi. Kh·ªüi ƒë·ªông l·∫°i...");
        delay(3000);
        ESP.restart();
    }
    
    Serial.println("‚úÖ K·∫øt n·ªëi WiFi th√†nh c√¥ng!");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    
    // Thi·∫øt l·∫≠p c√°c route cho webserver

    server.on("/command", HTTP_POST, handleCommand);
    server.begin();
    Serial.println("‚úÖ M√°y ch·ªß web ƒë√£ kh·ªüi ƒë·ªông");
    
    // G·ª≠i IP hi·ªán t·∫°i l√™n worker
    sendIPToWorker();

    pinMode(PH_PIN, INPUT);
    pinMode(TEMP_PIN, INPUT);
    pinMode(TDS_PIN, INPUT);
    pinMode(TUR_PIN, INPUT);

    pinMode(RELAY_PIN1, OUTPUT);
    pinMode(RELAY_PIN2, OUTPUT);

    sensors.begin();

    digitalWrite(RELAY_PIN1,HIGH);
    digitalWrite(RELAY_PIN2,HIGH);
    delay(2000);
    digitalWrite(RELAY_PIN1,LOW);
    digitalWrite(RELAY_PIN2,LOW);
}

void loop() {
    checkAndUpdateIP();    
    if (Serial.available()) {
        String input = Serial.readStringUntil('\n');  // ƒê·ªçc chu·ªói nh·∫≠p v√†o
        input.trim();  // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng

        if (input == "restart") {
            Serial.println("üîÑ ƒêang kh·ªüi ƒë·ªông l·∫°i ESP...");
            ESP.restart();
        }
        else if (input == "MT1"){
            digitalWrite(RELAY_PIN1,HIGH);
            delay(2000);
            digitalWrite(RELAY_PIN1,LOW);
        }
        else if (input == "MT2"){
            digitalWrite(RELAY_PIN2,HIGH);
            delay(2000);
            digitalWrite(RELAY_PIN2,LOW);
        }
        else if (input.startsWith("S")) {  // Nh·∫≠p "S-5.70"
            float newSlope = input.substring(1).toFloat();
            if (newSlope <= -10 || newSlope >= 0) {
                Serial.println("‚ùå L·ªói: Slope kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p gi√° tr·ªã t·ª´ -10 ƒë·∫øn 0.");
            } else {
                Slope = newSlope;
                Serial.print("‚úÖ Slope ƒë√£ c·∫≠p nh·∫≠t: ");
                Serial.println(Slope);
            }
        } 
        else if (input.startsWith("A")) {
            int newADC_cal = input.substring(1).toInt();
            if (newADC_cal < 1000 || newADC_cal > 3000) {
                Serial.println("‚ùå L·ªói: ADC_cal kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p gi√° tr·ªã t·ª´ 1000 ƒë·∫øn 3000.");
            } else {
                ADC_cal = newADC_cal;
                Serial.print("‚úÖ ADC_cal ƒë√£ c·∫≠p nh·∫≠t: ");
                Serial.println(ADC_cal);
            }
        } 
        else {
            Serial.println("‚ùå L·ªói: C√∫ ph√°p kh√¥ng h·ª£p l·ªá!");
        }
    }


    // G·ª≠i heartbeat ƒë·ªãnh k·ª≥
    if (millis() - lastHeartbeatTime > HEARTBEAT_INTERVAL) {
        sendHeartbeat();
        lastHeartbeatTime = millis();
    }
    
    if (millis() - lastPollTime > POLL_INTERVAL) {
        pollForCommands();
        lastPollTime = millis();
    }
    
    if (continuousMeasurement && millis() - lastDataSendTime > DATA_SEND_INTERVAL) {
        sendSensorDataToWorker();
        lastDataSendTime = millis();
    }
}
